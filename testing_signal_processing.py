from __future__ import division
import matplotlib.pyplot as plt
import numpy as np
from scipy.io import wavfile
import py_lib.noise_floor
import numpy as np
import matplotlib.pyplot as plt
import sys
from scipy.signal import argrelextrema

plt.rcParams['figure.dpi'] = 100
plt.rcParams['figure.figsize'] = (9, 7)

sampFreq, sound = wavfile.read('/home/daniel/Haskoli/VerkfraediX/jetson_nano_microphone_recording/Plastic_recordings/output12.wav')
sampFreq2, sound2 = wavfile.read('/home/daniel/Haskoli/VerkfraediX/jetson_nano_microphone_recording/noise_1sec_sample.wav')


sound = sound / 2.0**15
sound2 = sound2 / 2.0**15

length_in_s = sound.shape[0] / sampFreq
length_in_s2 = sound2.shape[0] / sampFreq2
print(length_in_s)

plt.subplot(2,1,1)
plt.plot(sound[:,0], 'r')
plt.xlabel("left channel, sample #")
plt.subplot(2,1,2)
plt.plot(sound[:,1], 'b')
plt.xlabel("right channel, sample #")
plt.tight_layout()
plt.show()

time = np.arange(sound.shape[0]) / sound.shape[0] * length_in_s

plt.subplot(2,1,1)
plt.plot(time, sound[:,0], 'r')
plt.xlabel("time, s [left channel]")
plt.ylabel("signal, relative units")
plt.subplot(2,1,2)
plt.plot(time, sound[:,1], 'b')
plt.xlabel("time, s [right channel]")
plt.ylabel("signal, relative units")
plt.tight_layout()
#plt.show()

signal = sound[:,0]
signal2 = sound2[:,0]

plt.plot(time[6000:7000], signal[6000:7000])
plt.xlabel("time, s")
plt.ylabel("Signal, relative units")
#plt.show()


fft_spectrum = np.fft.rfft(signal)
freq = np.fft.rfftfreq(signal.size, d=1./sampFreq)

fft_spectrum2 = np.fft.rfft(signal2)
freq2 = np.fft.rfftfreq(signal2.size, d=1./sampFreq2)

fft_spectrum_abs = np.abs(fft_spectrum)
fft_spectrum_abs_db = 10.0 * np.log10(fft_spectrum_abs)

fft_spectrum_abs2 = np.abs(fft_spectrum2)
fft_spectrum_abs_db2 = 10.0 * np.log10(fft_spectrum_abs2)

plt.plot(freq, fft_spectrum_abs)
plt.xlabel("frequency, Hz")
plt.ylabel("Amplitude, units")
plt.show()

plt.plot(freq, fft_spectrum_abs_db)
plt.xlabel("frequency, Hz")
plt.ylabel("Gain, dB")
plt.show()

plt.plot(freq2, fft_spectrum_abs2)
plt.xlabel("frequency, Hz")
plt.ylabel("Amplitude, units")
plt.show()

plt.plot(freq2, fft_spectrum_abs_db2)
plt.xlabel("frequency, Hz")
plt.ylabel("Gain, dB")
plt.show()

plt.plot(freq[:3000], fft_spectrum_abs[:3000])
plt.xlabel("frequency, Hz")
plt.ylabel("Amplitude, units")
#plt.show()

plt.plot(freq[:500], fft_spectrum_abs[:500])
plt.xlabel("frequency, Hz")
plt.ylabel("Amplitude, units")
plt.arrow(90, 5500, -20, 1000, width=2, head_width=8, head_length=200, fc='k', ec='k')
plt.arrow(200, 4000, 20, -1000, width=2, head_width=8, head_length=200, fc='g', ec='g')
#plt.show()


def noise_floor (data_points) :
    """Calculates the noise floor on the given fourier transform and plots it
    on the original fourier transform generated by the fourier transform module.

    - **parameters**, **types**, **return** and **return types**::
        :param data_points: Array of which noise floor is to be calculated.
        :type arr: floats[]

    """
    plt.figure (1)
    y_range = 1000
    x_range = 1000
    interval = len (data_points) / x_range
    #result = np.zeros ((x_range,y_range))
    results = []
    for i in range (x_range):
        data = data_points [int (i * interval) : int ((i + 1) * interval)]
        #print (type (data))
        ymin = min(data)
        ymax = max(data)
        y_interval = (ymax - ymin) / y_range
        total_points = len (data)
        print (i)
        for j in range (y_range) :
            #result [i][j] = (data > (j * y_interval)).sum() * 100 / total_points
            tmp = ()
            total = 0
            for elt in data:
                print(data)
                total += elt >= (j * y_interval)
                
            
            y_tmp = j * y_interval
            if total * 100 / total_points < 20:
                for elt in data:
                    if elt >= y_tmp:
                        results.append (elt)
                break
                #print ("within if ", results)
    
    
    #for row in result:
        #for elt in row:
            #print (elt)
    
    #x = np.array (range(len (result[400])))
    
    x = []
    y = []
    for elt in results:
        x.append (elt[1])
        y.append (elt[0])

    sp2 = plt.subplot(211)
    sp2.plot (x, y, ".", label="Noise Floor")
    legend = sp2.legend(loc='upper right', shadow=True)
    sp2.grid()
    return

noise = noise_floor(fft_spectrum_abs)